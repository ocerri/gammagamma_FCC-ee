pythia->SetMSTP(81,1); cosa fa?
Secondo noi abilita interazioni multiple

pythia MSTJ(22,2) fa decadere tutte le particelle con c\tau < 10 mm oppure
decadono con una certa probabilità (esponenzialmente)?

Cosa vuol dire “min-bias QCD”? Vuol dire che in una collisione tra protoni (LHC) due quark collidono in modo “hard” mentre gli altri collidono in modo soft producendo particelle leggere.

Perché usiamo la pseudorapidità e non la rapidità?
Che cosa rappresentano i grafici che dobbiamo riprodurre?

Delta(eta) è invariante relativistico? La distribuzione in eta è
piatta?

Che vuol dire tagged or untagged e+/e-?
e Anti tagging?



22/07 - 15

TAGLI da fare:

- Mettere nelle distribuzioni solo gli  ADRONI CARICHI(come li
seleziono?):
Fatto alle righe 257/258 levando dagli histo i leptoni e il W

- Taglio su energia adronica ricostruita 10 GeV < W < 125 GeV. W comprende l’energia di tutti gli adroni (anche quelli neutri) e l’energia dei fotoni. 

-Taglio su |eta|<1.5


 
il K0s ha un ctau di 2.68 cm e decade in pioni...Li dovrei rivelare.
Quindi metto i K0 negli histo, oppure lo faccio decadere in pioni e ci
metto quelli??
NO I K0 non vanno messi nelle distribuzioni e settando la decay zone a
ctau 10m i K0 non decadono e quindi non li vedo perche non sono nelle particelle cariche

- elettroni in arrivo scatterati a meno di 33 mrad, ci sarebbe stato
  il cut sull'energia rilasciata nei calorimetri minore di 50GeV ma
  dai Montecarlo hanno visto che se ha meno di 33 mrad allora l'energia
  e' quasi sempre minore dei 50GeV

- Devo avere almeno 3GeV nel ECAL

- Energia totale in ECAL e HCAL inferiore a 45 GeV -> in realtà ECAL e HCAL prendono solo particelle con angoli “grandi” e crediamo che questo taglio sia trascurabile (energia degli eventi gamma gamma è bassa e tanto particelle finiscono nella zona a piccoli angoli)

- Ci sarebbe da mettere anche l'energia trasversa mancante sia
minore di 5 GeV; -> in realtà questi sono eventi con neutrini, molto rari, che crediamo siano trascurabili per il nostro processo.

Questi ultimi tagli 4 tagli in ogni caso non vanno implementati perché sono detector based e noi stiamo facendo una simulazione a livello “superiore”, senza simulare i rivelatori.


22/07 - 18

Il programma va ma bisogna rivedere:
La normalizzazione (abbiamo cambiato il numero di BIN)
Numero di bin (5 e non 6)
controllare che non ci sia troppo uso di memoria: mettere delete alla fine di ogni loop

23/07 - 12

Per evitare spreco di memoria è conveniente compilare i programmi anziché interpretarli. Per fare questo conviene lanciare $root nomefile.C++ anziché usare $.L nomefile.C++
Non abbiamo inserito delete (forse non c’è bisogno)
Abbiamo fatto in modo che il programma prima disegni i grafici e poi li inserisca sul file, chiudendo il file. Per come era scritto prima, gli istogrammi veniva scritti direttamente sul file e poi mostrati. Ma quando il file veniva chiuso dal programma gli istogrammi venivano cancellati dal canvas.
Abbiamo aumentato la memoria virtuale dedicata ad un processo usando $ulimit .
Siamo riusciti ad eseguire il programma simulando 100000 eventi.

To do:
- aggiustare la normalizzazione che ancora non torna
- implementare un programmino che faccia simulare 1000 eventi a pythia per 10 volte, unisca gli istogrammi e poi faccia il merge degli istogrammi. In questo modo possiamo simulare tanti eventi senza avere problemi di memoria (Basta usare hadd sui file .root prodotti ogni volta; bisogna stare attenti ad usare seed diversi)


23/06 pomeriggio
Abbiamo lavorato su come usare i TTree.
Per crearli gurdare la macro di mike cerokov_exp.
Per leggerli Maurizio ci ha dato delle hint e poi siamo andati avanti.
Per prima cosa se si ha un .root con un tree dentro:
- lanciare $root nofile.root
- $_file0->ls()  //Fa vedere cosa c'e' nel .root
- $ nome_tree->Scan()  //serve solo a vedere come e' fatto il tree
- $ nome_tree->MakeClass("NomeClasse") //Crea la classe e il .C
Abbiamo quindi studiato com'e' fatta la classe.
La classe ha direttamente un puntatore al tree da cui e' stata creata
(fChain). Ha come campi le varie leaf del tree (Variabili associate a
ciascun evento).
Nel .C ci son le istruzioni su come creare e usare la classe per
looppare sui vari eventi. Ad esempio se creo un oggetto di questa
classe e faccio .GetEntry(i) carico nei campi dell'oggetto le variabili
dell’evento i-esimo.
Nel metodo loop e' predisposto uno scheletro su come fare il ciclo su
tutti gli eventi.

Incontro con DAVID:
La normalizzazione va bene in questo modo e circa 50k eventi ci
bastano per un fit decente.

TODO:

#ribinnare il dsigma in dpt in modo da avere il numero giusto di bin
per poterlo confontrare con gli articoli (~20 pt per GeV). 
#Inoltre fittare questo con una legge di potenza.

#Provare a cambiare il metodo i generazione di PYTHIA da 10 a 30 del
MSTP(14,) alla ln 172

#Provare a plottare(histo) il numero di adroni per evento che entrano
negli histo, e anche il W per evento mettendoli tutti anche quelli che
non passano il trigger

#Cercare altri articoli collegati a LEP2 che fanno dsigma in deta

#Occhio ai tagli su W e PT negli articoli del LEP2

22/06 

Fatto tutto TODO tranne provare a cambiare MSTP(14,…)
#Aggiungere il plot del particle ID

TODO:
#Creare cartella con file .root e reindirizzare la creazione del file
#Far tornare il fit (escludendo le code? e fare MSTP) -> meglio MSTP(14,10)
Se riusciamo fare un merge dei .root
Confrontare con i nuovi articoli (occhio ai tagli)

Per chiamare una funzione e passargli degli argomenti a root fare:
$root ‘pythia6_gammagamma_hadrons.C++(10,160,10)'

Domande:
Abbiamo visto che produciamo pochi eventi con un un solo adrone carico rispetto al numero di eventi senza adroni carichi o con due adroni carichi. Perché? è poco probabile fare un solo adrone.
Su 11000 eventi che passano i tagli vediamo tanti pioni (30000), abbastanza K (3000) e un po’ di protoni (~1000).
Come vengono prodotti i jet di adroni? Prima si formano tanti adroni e gluoni e solo alla fine, quando sono poco energetici, adronizzano.

